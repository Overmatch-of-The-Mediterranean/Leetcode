function getDP(root: TreeNode | null, dp:number[][]){
    // 对空节点的处理
    if(root === null) { 
        dp[0][0] = 0
        dp[0][1] = 10000 //不可能的情况
        dp[1][0] = 0
        dp[1][1] = 10000 // 不可能的情况
        return
     }

    // 对叶子节点的处理
     if(!root.left && !root.right){
         dp[0][0] = 10000 // 不可能的情况
         dp[0][1] = 1     
         dp[1][0] = 0
         dp[1][1] = 1     // 不包含父节点的摄像头
         return
     }

    // 非叶子节点的处理
     let l = [[0, 0],[0, 0]] // 相当于 左子节点对应的dp数组
     let r = [[0, 0],[0, 0]] // 相当于 右子节点对应的dp数组
     getDP(root.left, l)
     getDP(root.right, r)

    //  计算出左右子节点的dp数组后，计算自身节点的dp数组

    // 父节点，自身节点都没有摄像头，那么子节点至少要有一个摄像头，对应三种情况，从中取最小值
    dp[0][0] = Math.min(l[0][0] + r[0][1], l[0][1] + r[0][0], l[0][1] + r[0][1])

    // 父节点有，自身节点无，子节点则可有可无，对应四种情况，从中取最小值
    dp[1][0] = Math.min(dp[0][0], l[0][0] + r[0][0])

    // 父节点没有，自身节点有，子节点则可有可无，对应四种情况，从中取最小值
    dp[0][1] = Math.min(l[1][1] + r[1][1], l[1][0] + r[1][0], l[1][1] + r[1][0], l[1][0] + r[1][1]) + 1

    // 父节点有，自身节点有，子节点则可有可无，对应四种情况，从中取最小值
    dp[1][1] = dp[0][1]
    return

}



function minCameraCover(root: TreeNode | null): number {
    // dp数组的含义：不同情况下，最少需要多少个摄像头，才能覆盖包含本身节点所在的子树
    // 一维数组代表父节点是否有摄像头(0 代表无，1 代表有)，二维数组代表自身节点是否有摄像头(0 代表无，1 代表有)
    // 例如，dp[0][1]的含义代表，父节点无摄像头，子节点有摄像头的情况下，最少需要多少个摄像头，才能覆盖包含本身节点所在的子树
    let dp = [[0, 0],[0, 0]]
    
    getDP(root, dp)

    // 根节点，只有两种摄像头的情况
    return Math.min(dp[0][0], dp[0][1])
};